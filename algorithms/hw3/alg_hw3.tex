% HW Template for CS 6150, taken from https://www.cs.cmu.edu/~ckingsf/class/02-714/hw-template.tex
%
% You don't need to use LaTeX or this template, but you must turn your homework in as
% a typeset PDF somehow.
%
% How to use:
%    1. Update your information in section "A" below
%    2. Write your answers in section "B" below. Precede answers for all 
%       parts of a question with the command "\question{n}{desc}" where n is
%       the question number and "desc" is a short, one-line description of 
%       the problem. There is no need to restate the problem.
%    3. If a question has multiple parts, precede the answer to part x with the
%       command "\part{x}".
%    4. If a problem asks you to design an algorithm, use the commands
%       \algorithm, \correctness, \runtime to precede your discussion of the 
%       description of the algorithm, its correctness, and its running time, respectively.
%    5. You can include graphics by using the command \includegraphics{FILENAME}
%
\documentclass[11pt]{article}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{pifont}
\setlength{\parindent}{0pt}
\setlength{\parskip}{5pt plus 1pt}
\setlength{\headheight}{13.6pt}
\newcommand\question[2]{\vspace{.25in}\hrule\textbf{#1: #2}\vspace{.5em}\hrule\vspace{.10in}}
\renewcommand\part[1]{\vspace{.10in}\textbf{(#1)}}
\newcommand\algorith{\vspace{.10in}\textbf{Algorithm: }}
\newcommand\correctness{\vspace{.10in}\textbf{Correctness: }}
\newcommand\runtime{\vspace{.10in}\textbf{Running time: }}
\pagestyle{fancyplain}
\lhead{\textbf{\NAME\ (\UID)}}
\chead{\textbf{HW\HWNUM}}
\rhead{CS 6150, \today}
\begin{document}\raggedright
%Section A==============Change the values below to match your information==================
\newcommand\NAME{Jake Pitkin}  % your name
\newcommand\UID{u0891770}     % your utah UID
\newcommand\HWNUM{3}              % the homework number
%Section B==============Put your answers to the questions below here=======================

\question{1}{Easy Relatives of 3-SAT}

\part{a} Using a truth-table, we can prove that $x_1 \lor x_2$ and $\overline{x_1} \Rightarrow x_2$ are logically equivalent.

\begin{table}[H]
\centering
{\renewcommand{\arraystretch}{1.2}%
\begin{tabular}{| c | c | c | c | c |}
\hline
$x_1$ & $x_2$ & $\overline{x_1}$ & $x_1 \lor x_2$ & $\overline{x_1} \Rightarrow x_2$\\
\hline
0 & 0 & 1 & 0 & 0\\ \hline
0 & 1 & 1 & 1 & 1\\ \hline
1 & 0 & 0 & 1 & 1\\ \hline
1 & 1 & 0 & 1 & 1\\ \hline
\end{tabular}}
\end{table}

$\overline{x_1} \Rightarrow x_2$ can be restated as "if $\overline{x_1}$ is true, then $x_2$ must be true". On the first row of the truth table, we see a contradiction when $\overline{x_1}$ is true but $x_2$ is false. In all other cases the implication holds.

\part{b} 

\part{c}

\question{2}{Decision vs. Search}

\algorith 

\textbf{Setup:} Create a set C and populate it with all $v \in V$ in G and a set S that is initially empty. 

\textbf{Step 1:} If $\mathcal{O}(G, k)$ reports NO, report that an independent subset of size $k$ does not exist in $G$. Otherwise continue.

\textbf{Step 2:} Randomly select and \textbf{remove} a vertex $v$ from C. Remove $v$ from $G$ to form $G^\prime$. Keep some state so we can add $v$ back to $G^\prime$ to restore $G$.

\textbf{Step 3:} Call $\mathcal{O}(G^\prime, k)$ and if the oracle answers NO add $v$ to S and add $v$ back to $G^\prime$ to restore $G$. If the oracle responds with YES, replace $G$ with $G^\prime$ (this vertex is discarded).

\textbf{Step 4:} If $|S| < k$ repeat from step 2. If $|S|$ equals $k$, $S$ is an independent set of size $k$ and we are done.

\correctness From step 1, we know initially if $G$ contains an independent subset of size $k$. If a vertex $v$ can be removed from $G$ to form $G^\prime$ and $\mathcal{O}(G^\prime, k)$ returns YES, we know $G$ contains an independent subset of size $k$ and $v$ is not part of that subset. If $\mathcal{O}(G^\prime, k)$ returns NO, $G$ no longer contains an independent subset so we know $v$ is part of a independent subset so $v$ is added to $S$.

\runtime In the worst-case, each $v \in V$ in G must be removed from G (one at a time) and a call to $\mathcal{O}$ is made. Assuming the representation of the graph is an adjacency matrix, a node can be removed or added in $O(|V|)$ time. Giving $O(|V|)$ calls to $\mathcal{O}$ and $O(|V|^2)$ work to remove vertices.

\question{3}{Reductions, Reductions}

\part{a} To prove the Integer Linear Programming (ILP) problem is NP-hard, we can provide a polynomial time reduction of 3-SAT (a known NP-complete problem) to ILP. 3-SAT is the problem of given a formula of clauses in conjunctive normal form (CNF) where each clause contains at most three literals.

\textbf{Reduction}: Let the variables in the 3-SAT problem be $y_1$, $y_2$, $y_3$, ..., $y_n$. There will be identical variables $x_1$, $x_2$, $x_3$, ..., $x_n$ in our LIP problem restricted to the values $\{0, 1\}$ where $0$ represents false and $1$ represents true. Each linear constraint will contain the constants $a_1$, $a_2$, $a_3$, ..., $a_n$ and $b$.

	For each clause in the 3-SAT problem construct a linear constraint. If $y_i$ is present then $a_i$ is set to $-1$ otherwise $a_i$ is set to $0$. The constant $b$ is set to $-1$. If $y_i$ is negated in the clause, then $x_i$ equals $(1 - y_i)$.
	
\part{b}

\part{c}

\part{d}

\question{4}{Graphs - Definitions}

\part{a} 

\part{b} There cannot exist an undirected graph consisting of 10 nodes with degrees 2, 3, 4, 4, 7, 1, 4, 5, 3, 2 respectively.

\textbf{Proof:} The \textit{degree sum formula} states, given an undirected graph G, the sum of the degrees of all the vertices V in G is equal to twice the number of edges E in G. Where the degree of a vertex is the number of edge incident to the vertex.

$$\sum_{v \in V} deg(v) = 2|E|$$

Each edge in an undirected graph connects exactly two vertices. In the case of a looping edge that connects a vertex to itself, this adds two to the degree of that vertex.

We consider the sum of the given vertices.

$$\sum_{v \in V} deg(v) = 2|E|$$
$$35 = 2|E|$$
$$|E| = 17.5$$

The number of edges must be an integer value. Thus we know that the given graph does not satisfy the \textit{degree sum formula} and is an invalid graph.

\part{c}

\question{5}{Weary Traveler}

\algorith A directed graph G is constructed where airports are represented by vertices and flights are represented by edges. Each vertex contains the name of an airport. Edges contain the arrival time of the flight, departure time of the flight, and a flight id that uniquely identifies the flight (used to construct flight schedule when the shortest travel path is found).

	Four dictionaries are used to keep track of the following: the previous vertex in a path, the minimum travel time from the source to a given vertex, what time you will arrive at a given vertex to achieve the minimum travel time to that vertex from the source, and an id of the flight used to arrive at the a given vertex.
	
	The helper method \textit{arrival(u, w)} returns the arrival time of the edge that connects u and w, \textit{depart(u, w)} returns the departure time, and \textit{id(u, w)} returns the flight id.
	
	\algdef{SE}[VARIABLES]{Variables}{EndVariables}
   {\algorithmicvariables}
   {\algorithmicend\ \algorithmicvariables}
\algnewcommand{\algorithmicvariables}{\textbf{Initialize}}

\begin{algorithm}[H]
\caption{Minimum Total Travel Time}
\label{CHalgorithm}
\begin{algorithmic}[1]
\Variables
\State $\mathbf{travel\_time[v]} = \infty$ For all $v \in V$ in G
\State $\mathbf{prev[v]} = null$ For all $v \in V$ in G
\State $\mathbf{arrival\_time[v]} = -\infty$ For all $v \in V$ in G
\State $\mathbf{flight\_id[v] = null}$ For all $v \in V$ in G
\State
\State $\mathbf{travel\_time[source]} = 0$
\State $\mathbf{arrival\_time[source]} = $ time arrived at source airport
\State $\mathbf{PriorityQueue\ q} = [source]$
\EndVariables
\State
\Procedure{minimum\_total\_travel\_time(G, source, dest)}{}
\While{q is non-empty}
\State u = q.peek()  \# Get the top priority item but don't remove it
\If{u == dest}
\State \Return schedule with smallest total travel time
\EndIf
\For{neighbors w in u} \# Consider each vertex with an edge from u
\State new\_travel\_time = arrival(u, w) - arrival\_time[u] + travel\_time[u]
\If{arrival\_time[u] + 10 $\leq$ depart(u, w) \&\& new\_dist $<$ travel\_time[w]}
\State travel\_time[w] = new\_travel\_time
\State arrival\_time[w] = arrival(u, w)
\State flight\_id[w] = id(u, w)
\State 
\State q.update(w) \# Add w to the priority queue or update it's priority
\EndIf
\EndFor
\State q.pop() \# Remove from the queue the vertex with the highest priority
\EndWhile
\State \Return No path exists
\EndProcedure
\end{algorithmic}
\end{algorithm}

The algorithm is Dijkstra's algorithm with small modifications. On line 14, if we de-queue the destination vertex we are done and can construct the shortest path. This is accomplished using the \textit{prev} and \textit{flight\_id} dictionaries starting at the destination vertex and working backwards to the source vertex. On line 19, the travel time to travel from u to w is calculated, combining flight time and time spent waiting in airports. In contrast to traditional weighted graphs, this is necessary since time will be spent traveling while inside airports (nodes) and while on flights (edges).

A priority queue implemented with a min-heap is used to store the vertices waiting to be processed so we can efficiently get the vertex with the highest priority. The travel time from the source to the vertex is stored in the priority queue with the vertex and is used to determine priority.

\correctness

\runtime

\end{document}
