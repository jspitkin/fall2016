% HW Template for CS 6150, taken from https://www.cs.cmu.edu/~ckingsf/class/02-714/hw-template.tex
%
% You don't need to use LaTeX or this template, but you must turn your homework in as
% a typeset PDF somehow.
%
% How to use:
%    1. Update your information in section "A" below
%    2. Write your answers in section "B" below. Precede answers for all 
%       parts of a question with the command "\question{n}{desc}" where n is
%       the question number and "desc" is a short, one-line description of 
%       the problem. There is no need to restate the problem.
%    3. If a question has multiple parts, precede the answer to part x with the
%       command "\part{x}".
%    4. If a problem asks you to design an algorithm, use the commands
%       \algorithm, \correctness, \runtime to precede your discussion of the 
%       description of the algorithm, its correctness, and its running time, respectively.
%    5. You can include graphics by using the command \includegraphics{FILENAME}
%
\documentclass[11pt]{article}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{pifont}
\setlength{\parindent}{0pt}
\setlength{\parskip}{5pt plus 1pt}
\setlength{\headheight}{13.6pt}
\newcommand\question[2]{\vspace{.25in}\hrule\textbf{#1: #2}\vspace{.5em}\hrule\vspace{.10in}}
\renewcommand\part[1]{\vspace{.10in}\textbf{(#1)}}
\newcommand\algorith{\vspace{.10in}\textbf{Algorithm: }}
\newcommand\correctness{\vspace{.10in}\textbf{Correctness: }}
\newcommand\runtime{\vspace{.10in}\textbf{Running time: }}
\pagestyle{fancyplain}
\lhead{\textbf{\NAME\ (\UID)}}
\chead{\textbf{HW\HWNUM}}
\rhead{CS 6150, \today}
\begin{document}\raggedright
%Section A==============Change the values below to match your information==================
\newcommand\NAME{Jake Pitkin}  % your name
\newcommand\UID{u0891770}     % your utah UID
\newcommand\HWNUM{2}              % the homework number
%Section B==============Put your answers to the questions below here=======================

\question{1}{Probability of $k$ Heads}

\question{2}{Count Number of Parsings}
\textit{Collaboration with Maks Cegielski-Johnson.}

\algorith The following is an algorithm for counting the number of ways a string can be parsed, given a language of valid words.

\algdef{SE}[VARIABLES]{Variables}{EndVariables}
   {\algorithmicvariables}
   {\algorithmicend\ \algorithmicvariables}
\algnewcommand{\algorithmicvariables}{\textbf{Global Variables}}

\begin{algorithm}[H]
\caption{Count number of parsings}
\label{CHalgorithm}
\begin{algorithmic}[1]
\Variables
\State $\mathbf{cache} = $ dictionary of parsings counts for a given word
\State $\mathbf{language} =$ collection of words in the language
\State $\mathbf{L} =$ length of the language
\EndVariables
\State
\Procedure{Parsing\_Count(s)}{}
\If {len(s) == 0}
	\State \Return 1
\EndIf
\State
\If {s in cache}
	\State \Return cache[s]
\EndIf
\State
\For {index in range(min(N , L) + 1)}
	\State \textbf{substring} = the first \textit{index} characters of s
	\If {substring in language}
		\State \textbf{remaining} = s with substring removed from the front of s
		\State count = count + \textbf{parsing\_count}(remaining)
	\EndIf
\EndFor
\State
\State cache[w] = count
\State \Return count
\EndProcedure
\end{algorithmic}
\end{algorithm}

The recursive algorithm will try every possible parse of $s$, using the words in the language. At each call of the recursive algorithm, $s$ is scanned left to right for matches with words in the language. If a match is found, a substring is formed (removing the match from the beginning of $s$) and passed to \textit{parsing\_count} and the process is repeated on the substring. The scan of $s$ is continued to find additional parses. Scanning continues the minimum of N and L. A parse is successful if the string passed to \textit{parsing\_count} is empty. The total count of parses is returned once all possibilities are tested.

\correctness The algorithm will terminate as the input string $s$ gets smaller with each recursive call to \textit{parsing\_count} (moving towards the base case) or no parsing is found and no recursive call is made.

We can observe that we will find every possible parsing as we exhaustively try every possible parsing of $s$ given the language. Thus the algorithm is always correct. 

\runtime There are $2^{N-1}$ possible parsings in the worst-case. This worst-case is when $s$ is a string consisting of all the same letter (ex. aaaaa) and the language is a growing sequence of length N (ex. a, aa, aaa, aaaa, aaaaa).

 We combat this exponential runtime by caching the parse counts of the substrings of $s$. In the worst-case, there are N entries in the language that need to be parsed and cached. The recursion tree with have $N$ levels, and there will be $N-k$ lookups on each level where $k$ is the recursion level. 
 $$\sum_{i=1}^{n} n-i = \frac{n(n-1)}{2}$$
 
 This is making the assumption that the language is stored in a hash set structure that provides constant time lookup.
 
 \framebox[1.2\width]{$O(n^2)$ time complexity}
 
\question{3}{The Ill-prepared Burglar}

\part{a} Consider the scenario where the ill-prepared burglar can carry 10 pounds and the house has the following items.

\begin{table}[H]
\centering
{\renewcommand{\arraystretch}{1.2}%
\begin{tabular}{| c | c | c |}
\hline
Item& Value& Weight\\
\hline
T.V. & 8& 9\\ \hline
Laptop & 5& 5\\ \hline
Fine Art & 7& 5\\ \hline
\end{tabular}}
\end{table}

His strategy of picking the most valuable items first won't be most optimal here. He will end up with the T.V. in his bag with a value of 9. The most optimal strategy would be taking the laptop and fine art, putting his loot value at 12.

\part{b} Again, the ill-prepared burglar can only carry 10 pounds, this time picking the items with the best ratio.

\begin{table}[H]
\centering
{\renewcommand{\arraystretch}{1.2}%
\begin{tabular}{| c | c | c | c |}
\hline
Item& Value& Weight& Ratio\\
\hline
Finer Art & 9& 6&1.5 \\ \hline
iPad & 5& 5&1\\ \hline
jewelry  & 5& 5&1\\ \hline
\end{tabular}}
\end{table}

The burglar's new ratio strategy will lead him to pick the finer art, with no room for anything else and a value of 9. The optimal choice would of been to take the iPad and jewelry for a total value of 10.

\algorith The following is an algorithm for finding the max total value of items that can fit in a bank locker.

\begin{algorithm}[H]
\caption{Count number of parsings}
\label{CHalgorithm}
\begin{algorithmic}[1]
\Variables
\State $\mathbf{V} = $ collection of the values for each item
\State $\mathbf{W} =$ collection of the weights for each item
\State $\mathbf{cache} =$ the max value of items for a given size
\EndVariables
\State
\Procedure{Max\_Value(weight)}{}
\For {cur\_weight in range(1, weight + 1)}
	\For {index in range(len(V))}
		\If {cur\_weight $\geq$ W[index]}
			\If {V[index] + cache[cur\_weight - W[index]] $>$ cache[cur\_weight]}
				\State cache[cur\_weight] = V[index] + cache[cur\_weight - W[index]]
			\EndIf
		\EndIf
	\EndFor
\EndFor
\State
\State \Return cache[weight]
\EndProcedure
\end{algorithmic}
\end{algorithm}

TODO: explanation of algorithm

\correctness

\runtime 

\part{d}

\question{4}{Central Node in Trees}

\question{5}{Faster LIS}

\part{a}

\part{b}

\question{6}{Maximizing Happiness}

\part{a} Consider the following setting of children and gifts.

\begin{table}[H]
\centering
{\renewcommand{\arraystretch}{1.2}%
\begin{tabular}{| c | c | c |}
\hline
& gift 1 & gift 2 \\ \hline
child 1 & 2& 1 \\ \hline
child 2 & 2,999& 1\\ \hline
\end{tabular}}
\end{table}

If Santa is in a hurry and assigns gifts greedily, child 1 will receive present 1 and child 2 will receive present 2. This will result in a total value of 3. The best assignment that could take place is giving child 2 gift 1 and giving child 1 gift 2. This will result in a total value of 3,000. 

\part{b}

\end{document}
